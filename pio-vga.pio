.program vga_data
.wrap_target
    // Trigger the ISR to load the line buffer
    irq set 0
        
    // Set and wait the HFP delay
public hfp_load:
    set X, 12
hfp_loop:
    jmp X--, hfp_loop [1]
    
    // Assert HSYNC
    set pins, 1 [3]
    
    // Load and wait HSYNC delay
    set X, 22 [3]
hsync_loop:
    jmp X--, hsync_loop [7]
    
    // Deassert HSYNC
    set pins, 0
    
    // Load and wait the HBP delay
    set X, 22 [1]
hbp_loop:
    jmp X--, hbp_loop [3]
        
    // Load the HACTIVE count
    mov X, Y
hactive_loop:
    out PINS, 4
    jmp X--, hactive_loop
.wrap

% c-sdk {
#include "hardware/dma.h"
#include "hardware/pio.h"
#include "hardware/gpio.h"
#include "hardware/irq.h"
#include "hardware/clocks.h"

static inline void vga_data_init(PIO pio, uint sm, uint prog_offset, uint rgb_base, uint hsync_pin, float freq)
{
    pio_sm_config c = vga_data_program_get_default_config(prog_offset);
    sm_config_set_out_pins(&c, rgb_base, 4);
    sm_config_set_set_pins(&c, hsync_pin, 1);
    sm_config_set_out_shift(&c, true, true, 8);   // Auto-pull for OUT instruction
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);
    
    float div = clock_get_hz(clk_sys) / freq;    
    sm_config_set_clkdiv(&c, div);
        
    pio_sm_set_consecutive_pindirs(pio, sm, rgb_base, 4, true); 
    pio_sm_set_consecutive_pindirs(pio, sm, hsync_pin, 1, true);
    for (int i=0; i<4; i++) pio_gpio_init(pio, rgb_base + i);
    pio_gpio_init(pio, hsync_pin);
            
    pio_sm_init(pio, sm, prog_offset, &c);
    
    pio->txf[sm] = 641;
    pio_sm_exec(pio, sm, pio_encode_pull(false, false));
    pio_sm_exec(pio, sm, pio_encode_out(pio_y, 32));
    
    pio_sm_set_enabled(pio, sm, true);
}

static inline void setup_vga_irq(PIO pio, irq_handler_t handler)
{
    uint pio_num = pio_get_index(pio);
    uint irq_num = (pio_num==0 ? PIO0_IRQ_0 : PIO1_IRQ_0);
    pio_set_irq0_source_enabled(pio, pis_interrupt0, true);
    irq_set_exclusive_handler(irq_num, handler);
    irq_set_enabled(irq_num, true);
}    

static inline void vga_configure_send_dma(int dma_channel, PIO pio, uint sm_data)
{
    dma_channel_config config = dma_channel_get_default_config(dma_channel);
    channel_config_set_transfer_data_size(&config, DMA_SIZE_8);
    channel_config_set_read_increment(&config, true);
    channel_config_set_write_increment(&config, false);
    
    // Pace the DMA based on the TX fifo of the data SM
    uint pio_num = pio_get_index(pio);
    uint dreq = (pio_num==0 ? DREQ_PIO0_TX0 : DREQ_PIO1_TX0) + sm_data;
    channel_config_set_dreq(&config, dreq);
    
    uint32_t *dst_ptr = (uint32_t *)&(pio->txf[sm_data]);
    
    dma_channel_configure(
        dma_channel,
        &config,
        dst_ptr,                
        0,              // No address yet
        0,              // Number of transfers 
        false           // Don't start immediately
    );
}

static inline void vga_start_send_dma(int dma_channel, uint8_t *buf, int buf_len)
{
    dma_channel_transfer_from_buffer_now(dma_channel, buf, buf_len);
}


%}
